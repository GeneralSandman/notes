### 操作系统学习笔记
# lab1
## 1.探测物理内存大小和方法
[探测物理内存：BIOS在实模式下发送中断E820h](https://objectkuan.gitbooks.io/ucore-docs/lab2/lab2_3_5_probe_phymem_methods.html)
**
当 ucore 被启动之后，最重要的事情就是知道还有多少内存可用，一般来说，获取内存大小的方法由 BIOS 中断调用和直接探测两种。但BIOS 中断调用方法是一般只能在实模式下完成，而直接探测方法必须在保护模式下完成。通过 BIOS 中断获取内存布局有三种方式，都是基于INT 15h中断，分别为88h e801h e820h。但是 并非在所有情况下这三种方式都能工作。在 Linux kernel 里，采用的方法是依次尝试这三 种方法。而在本实验中，我们通过e820h中断获取内存信息。因为e820h中断必须在实模式下使用，所以我们在 bootloader 进入保护模式之前调用这个 BIOS 中断，并且把 e820 映 射结构保存在物理地址0x8000处。结构体为e80map.
**

## 2.保护模式
**
80386就是通过在实模式下初始化控制寄存器（如GDTR，LDTR，IDTR与TR等管理寄存器）以及页表，然后再通过设置CR0寄存器使其中的保护模式使能位置位，从而进入到80386的保护模式。当80386工作在保护模式下的时候，其所有的32根地址线都可供寻址，物理寻址空间高达4GB。
**
**
只有在保护模式下，80386的全部32根地址线有效，可寻址高达4G字节的线性地址空间和物理地址空间，可访问64TB（有2\^14个段，每个段最大空间为2^32字节）的逻辑地址空间，可采用分段存储管理机制和分页存储管理机制。这不仅为存储共享和保护提供了硬件支持，而且为实现虚拟存储提供了硬件支持。
**
## 3.GDT和LDT
** 
GDT:全局描述符表:唯一存放段寄存器的数组,配合保护模式进行段寻址;在进程切换中具有重要意义;进程的总目录表;存放着每一个任务的局部描述符表(LDT)地址和任务状态信息;可用于各进程中段的寻址,现场恢复.
**

**
IDT:中断描述符表:存放保护模式下所有中断服务程序的入口地址,类似于实模式下的中断向量表
**


保护模式下，有两个段表：GDT（Global Descriptor Table）和LDT（Local Descriptor Table），每一张段表可以包含8192 (2^13)个描述符[1]，因而最多可以同时存在2 * 2^13 = 2\^14个段。虽然保护模式下可以有这么多段，逻辑地址空间看起来很大，但实际上段并不能扩展物理地址空间，很大程度上各个段的地址空间是相互重叠的。目前所谓的64TB（2\^(14+32)=2\^46）逻辑地址空间是一个理论值，没有实际意义。在32位保护模式下，真正的物理空间仍然只有2^32字节那么大。

## 4.[保护模式和分段机制](https://objectkuan.gitbooks.io/ucore-docs/lab1/lab1_3_2_1_protection_mode.html)
## 5.CPL、RPL和DPL特权级
- ** CPL：当前特权级（Current Privilege Level) 保存在CS段寄存器（选择子）的最低两位，CPL就是当前活动代码段的特权级，并且它定义了当前所执行程序的特权级别）**
- ** DPL：描述符特权（Descriptor Privilege Level） 存储在段描述符中的权限位，用于描述对应段所属的特权等级，也就是段本身真正的特权级。**
- ** RPL：请求特权级RPL(Request Privilege Level) RPL保存在选择子的最低两位。RPL说明的是进程对段访问的请求权限，意思是当前进程想要的请求权限。RPL的值由程序员自己来自由的设置，并不一定RPL>=CPL，但是当RPL<CPL时，实际起作用的就是CPL了，因为访问时的特权检查是判断：max(RPL,CPL)<=DPL是否成立，所以RPL可以看成是每次访问时的附加限制，RPL=0时附加限制最小，RPL=3时附加限制最大。**

## 6.分段存储管理机制
**
只有在保护模式下才能使用分段存储管理机制。分段机制将内存划分成以起始地址和长度限制这两个二维参数表示的内存块，这些内存块就称之为段（Segment）。编译器把源程序编译成执行程序时用到的代码段、数据段、堆和栈等概念在这里可以与段联系起来，二者在含义上是一致的。
分段机涉及4个关键内容：逻辑地址、段描述符（描述段的属性）、段描述符表（包含多个段描述符的“数组”）、段选择子（段寄存器，用于定位段描述符表中表项的索引）。转换逻辑地址（Logical Address,应用程序员看到的地址）到物理地址（Physical Address, 实际的物理内存地址）分以下两步：
1.分段地址转换：CPU把逻辑地址（由段选择子selector和段偏移offset组成）中的段选择子的内容作为段描述符表的索引，找到表中对应的段描述符，然后把段描述符中保存的段基址加上段偏移值，形成线性地址（Linear Address）。如果不启动分页存储管理机制，则线性地址等于物理地址。 
2.分页地址转换，这一步中把线性地址转换为物理地址。
**

## 7.段描述符
**
kern/mm/mmu.h中的struct segdesc 为段描述符定义
![段描述符结构]()
**

## 8.全局描述符表
** 
全局描述符表的是一个保存多个段描述符的“数组”，其起始地址保存在全局描述符表寄存器GDTR中。
**

## 9.选择子
**
线性地址部分的选择子是用来选择哪个描述符表和在该表中索引一个描述符的。
**

- **索引（Index）：在描述符表中从8192个描述符中选择一个描述符。处理器自动将这个索引值乘以8（描述符的长度），再加上描述符表的基址来索引描述符表，从而选出一个合适的描述符。**
- **表指示位（Table Indicator，TI）：选择应该访问哪一个描述符表。0代表应该访问全局描述符表（GDT），1代表应该访问局部描述符表（LDT）。**
- **请求特权级（Requested Privilege Level，RPL）：保护机制，在后续试验中会进一步讲解。**

1.逻辑地址有一个16位的段寄存器（也称段选择子，段选择子）和一个32位的偏移量构成。
2.启动分段机制，未启动分页机制：逻辑地址--> (分段地址转换) -->线性地址==物理地址
3.启动分段和分页机制：逻辑地址--> (分段地址转换) -->线性地址-->(分页地址转换) -->物理地址
4.[CPU如何访问硬盘](https://objectkuan.gitbooks.io/ucore-docs/lab1/lab1_3_2_3_dist_accessing.html)

## 10.线性地址
**
线性地址空间是80386处理器通过段（Segment）机制控制下的形成的地址空间。在操作系统的管理下，每个运行的应用程序有相对独立的一个或多个内存空间段，每个段有各自的起始地址和长度属性，大小不固定，这样可让多个运行的应用程序之间相互隔离，实现对地址空间的保护。
**

**
在操作系统完成对80386处理器段机制的初始化和配置（主要是需要操作系统通过特定的指令和操作建立全局描述符表，完成虚拟地址与线性地址的映射关系）后，80386处理器的段管理功能单元负责把虚拟地址转换成线性地址，在没有下面介绍的页机制启动的情况下，这个线性地址就是物理地址。
**

**
相对而言，段机制对大量应用程序分散地使用大内存的支持能力较弱。所以Intel公司又加入了页机制，每个页的大小是固定的（一般为4KB），也可完成对内存单元的安全保护，隔离，且可有效支持大量应用程序分散地使用大内存的情况。
**
**
在操作系统完成对80386处理器页机制的初始化和配置（主要是需要操作系统通过特定的指令和操作建立页表，完成虚拟地址与线性地址的映射关系）后，应用程序看到的逻辑地址先被处理器中的段管理功能单元转换为线性地址，然后再通过80386处理器中的页管理功能单元把线性地址转换成物理地址.
**

## 11.[Intel 80386寄存器](https://objectkuan.gitbooks.io/ucore-docs/lab0/lab0_2_5_3_intel_80386_registers.html)

**
1.CS:代码段寄存器:指向CPU当前执行代码所在的区域
2.IP:指令指针寄存器:与CS组合即为将要执行指令所在地址(CS<<4 + IP)
**

## 12.A20
**
打开A20,可实现32位寻址
**

## 13.知识点
**
1.BIOS的入口地址为OXFFFF0,功能:建立中断向量表和中断服务程序
2.BIOS把第一扇区的代码加载到OX7C00处
3.Bootloader的起始地址为0X7c00,BIOS通过把设置CS=0,IP=7c00使CPU开始执行bootloader代码
4.Bootloader首先建立保护模式,设置A20,然后建立C语言环境,后转到C语言程序加载操作系统镜像(内核镜像为ELF格式)
5.**

